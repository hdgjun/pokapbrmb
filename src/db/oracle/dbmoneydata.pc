#include "db/db.h"
#include "db/dbmoneydata.h"
#include "common.h"
#include "pokafile.h"
int DbsMoneydata(int oprType, MONEYDATAR *fileRecord)
{
	struct sqlca sqlca;
	sql_context ctx;
	ctx = (sql_context)pthread_getspecific(p_Thread_key);
	EXEC SQL CONTEXT USE :ctx;

	EXEC SQL BEGIN DECLARE SECTION;
	MONEYDATAR  tmpData;
	int co;
	char db_name[20];
	char date[21];
	EXEC SQL END DECLARE SECTION;

	memset(&tmpData, 0x00, sizeof(MONEYDATAR));
	memcpy(&tmpData, fileRecord, sizeof(MONEYDATAR));

	switch (oprType)
	{
		case DBS_INSERT:
			EXEC SQL INSERT  INTO
			   MONEYDATA(
				PERCODE,
				COLTIME,
				MON,
				MONTYPE,
				MONVAL,
				MONVER,
				TRUEFLAG,
				OPERATORID,
				OPERDATE,
				BUNDLEID,
				PACKAGEID,
				CHECKER,
				IMAGEPATH,
				BUSINESSTYPE,
				MONBOXID,
				ATMID,
				ADDMONOPERATOR,
				ADDMONCHECKER,
				BANKNO,
				FILENAME,
				AGENCYNO
				)
				VALUES(
				:tmpData.percode,
				 to_date(:tmpData.coltime,'yyyy-mm-dd hh24:mi:ss'),
				:tmpData.mon,
				:tmpData.montype,
				:tmpData.monval,
				:tmpData.monver,
				:tmpData.trueflag,//"0",
				:tmpData.operatorid,
				 SYSDATE,
				:tmpData.bundleid,
				:tmpData.packageid,
				:tmpData.checker,
				:tmpData.imagepath,
				:tmpData.businesstype,
				:tmpData.monboxid,
				:tmpData.atmid,
				:tmpData.addmonoperator,
				:tmpData.addmonchecker,
				:tmpData.bankno,
				:tmpData.filename,
				:tmpData.agencyno
				 );
			return JudgeSqlExecResultLocal(0,"DBS_INSERT ",&sqlca);
		case DBS_DELETE:
			 EXEC SQL SELECT
				COUNT(1)
			 INTO
				 :co
			 FROM
			 USER_TAB_PARTITIONS
			 WHERE TABLE_NAME ='MONEYDATA';
			 if(co<=0){
				 EXEC SQL DELETE FROM MONEYDATA WHERE OPERDATE < to_date(:tmpData.operdate,'yyyymmdd');
				 return JudgeSqlExecResultLocal(0,"DBS_DELETE MONEYDATA1",&sqlca);
			 }else{
				 memset(db_name,0x00,sizeof(db_name));
				 memcpy(db_name,g_param.DBUser,strlen(g_param.DBUser));

				 memset(date,0x00,sizeof(date));
				 memcpy(date,tmpData.operdate,strlen(tmpData.operdate));
			//	 EXEC SQL AT :db_name EXECUTE
				 EXEC SQL EXECUTE
				        BEGIN
							DELETE_MONEYDATA_PARTITION(:date);
				        END;
				 END-EXEC;
				 return JudgeSqlExecResultLocal(0,"DBS_DELETE MONEYDATA2",&sqlca);
			 }

	}
   return SUCESS;
}

int DbsDoubtMoneydata(int oprType,MONEYDATAR *fileRecord)
{
	struct sqlca sqlca;
	sql_context ctx;
	ctx = (sql_context)pthread_getspecific(p_Thread_key);
	EXEC SQL CONTEXT USE :ctx;

	EXEC SQL BEGIN DECLARE SECTION;
	MONEYDATAR  tmpData;
	EXEC SQL END DECLARE SECTION;

	memset(&tmpData, 0x00, sizeof(MONEYDATAR));
	memcpy(&tmpData, fileRecord, sizeof(MONEYDATAR));

	switch (oprType)
	{
		case DBS_INSERT:
			EXEC SQL INSERT  INTO
			DOUBTMONEYDATA(
				PERCODE,
				COLTIME,
				MON,
				MONTYPE,
				MONVAL,
				MONVER,
				TRUEFLAG,
				OPERATORID,
				OPERDATE,
				BUNDLEID,
				PACKAGEID,
				CHECKER,
				IMAGEPATH,
				BUSINESSTYPE,
				MONBOXID,
				ATMID,
				ADDMONOPERATOR,
				ADDMONCHECKER,
				BANKNO,
				FILENAME,
				AGENCYNO
				)
				VALUES(
				:tmpData.percode,
				 to_date(:tmpData.coltime,'yyyy-mm-dd hh24:mi:ss'),
				:tmpData.mon,
				:tmpData.montype,
				:tmpData.monval,
				:tmpData.monver,
				:tmpData.trueflag,//"0",
				:tmpData.operatorid,
				 SYSDATE,
				:tmpData.bundleid,
				:tmpData.packageid,
				:tmpData.checker,
				:tmpData.imagepath,
				:tmpData.businesstype,
				:tmpData.monboxid,
				:tmpData.atmid,
				:tmpData.addmonoperator,
				:tmpData.addmonchecker,
				:tmpData.bankno,
				:tmpData.filename,
				:tmpData.agencyno
				 );
			return JudgeSqlExecResultLocal(0,"DBS_INSERT ",&sqlca);

		case DBS_DELETE:
		 EXEC SQL DELETE FROM DOUBTMONEYDATA WHERE OPERDATE < to_date(:tmpData.operdate,'yyyymmdd');
		 return JudgeSqlExecResultLocal(0,"DBS_DELETE DOUBTMONEYDATA",&sqlca);
	}
   return SUCESS;
}
